require 'pp'

require_relative 'integral/calculator'

task :run do

  collected_functions = collect_functions
  collected_borders   = collect_borders

  step     = 0.0001
  quantity = 100_000

  puts <<-OUTPUT
    ============== DATA ==============
    Functions:
    \t f(x) = a_param * (1.0 - x) * x 
    \t f(y) = Math.exp(-m_param * y) 
    \t f(z) = Math.sin(Math::PI * k_param * z) 
    Borders:
    \t for x = #{collected_borders[:x]}
    \t for y = #{collected_borders[:y]}
    \t for x = #{collected_borders[:z]}
    Quantity: \t\t\t\t#{quantity}
    Step (for rectangles method only): \t#{step}
    ==============/DATA ==============
  OUTPUT

  integrator = Integral::Calculator.new()

  integrator.engine = Integral::Engine::Direct.new(collected_borders, collected_functions, quantity)
  direct = integrator.result

  integrator.engine = Integral::Engine::Rectangles.new(collected_borders, collected_functions, step)
  rectangles = integrator.result
  rectangles_diff_direct = volume_diff_between(rectangles, direct)

  integrator.engine = Integral::Engine::SimplestMonteCarlo.new(collected_borders, collected_functions, quantity)
  simplest_mc = integrator.result
  simplest_diff_direct = volume_diff_between(simplest_mc, direct)

  integrator.engine = Integral::Engine::GeometricMonteCarlo.new(collected_borders, collected_functions, quantity)
  geometric_mc = integrator.result
  geometric_diff_direct = volume_diff_between(geometric_mc, direct)

  puts <<-OUTPUT
    ============= RESULT =============
    Direct: 
      volume:  #{direct[:volume]}
      mistake: #{direct[:mistake]}
    Rectangles:
      volume:   \t\t#{rectangles[:volume]}
      mistake:  \t\t#{rectangles[:mistake]}
      quantity: \t\t#{rectangles[:quantity]}
      differend to direct: \t#{rectangles_diff_direct}
    The Simplest Monte Carlo:
      volume:   \t\t#{simplest_mc[:volume]}
      mistake:  \t\t#{simplest_mc[:mistake]}
      quantity: \t\t#{simplest_mc[:quantity]}
      differend to direct: \t#{simplest_diff_direct}
    The Geometric Monte Carlo:
      volume:   \t\t#{geometric_mc[:volume]}
      mistake:  \t\t#{geometric_mc[:mistake]}
      quantity: \t\t#{geometric_mc[:quantity]}
      differend to direct: \t#{geometric_diff_direct}
    =============/RESULT =============
  OUTPUT

end

def volume_diff_between(this, other)
  (this[:volume] - other[:volume]).abs
end

def collect_functions
  a_param = m_param = k_param = 1.0

  func_x = ->(x) { a_param.to_f * (1.0 - x.to_f) * x.to_f }
  func_y = ->(y) { Math.exp(-m_param.to_f * y.to_f) }
  func_z = ->(z) { Math.sin(Math::PI * k_param.to_f * z.to_f) }

  {
    x: func_x,
    y: func_y,
    z: func_z 
  }
end

def collect_borders
  border_right = {
    x: 1,
    y: 1,
    z: 1
  }

  {
    x: Range.new(0, border_right[:x].to_f),
    y: Range.new(0, border_right[:y].to_f),
    z: Range.new(0, border_right[:z].to_f)
  }
end
